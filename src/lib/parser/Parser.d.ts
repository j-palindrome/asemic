import { AsemicPt, BasicPt } from '../blocks/AsemicPt';
import { AsemicFont } from '../defaultFont';
import { InputSchema } from '../../renderer/inputSchema';
import { Transform } from '../types';
import { AsemicGroup } from './core/AsemicGroup';
import { cloneTransform } from './core/Transform';
import { DataMethods } from './methods/Data';
import { DrawingMethods } from './methods/Drawing';
import { ExpressionMethods } from './methods/Expressions';
import { OSCMethods } from './methods/OSC';
import { ParsingMethods } from './methods/Parsing';
import { SceneMethods } from './methods/Scenes';
import { TextMethods } from './methods/Text';
import { TransformMethods } from './methods/Transforms';
import { UtilityMethods } from './methods/Utilities';
export { AsemicGroup };
export declare class Parser {
    rawSource: string;
    presets: Record<string, InputSchema['params']>;
    mode: "normal" | "blank";
    adding: number;
    debugged: Map<string, {
        errors: string[];
    }>;
    groups: AsemicGroup[];
    settings: {
        debug: boolean;
        h: number | "window" | "auto";
        perform: boolean;
        scene: number;
        fullscreen: boolean;
        folder: string;
    };
    static defaultSettings: {
        debug: boolean;
        h: number | "window" | "auto";
        perform: boolean;
        scene: number;
        fullscreen: boolean;
        folder: string;
    };
    currentCurve: AsemicPt[];
    currentTransform: Transform;
    transformStack: Transform[];
    namedTransforms: Record<string, Transform>;
    totalLength: number;
    pausedAt: string[];
    pauseAt: string | false;
    sceneList: {
        start: number;
        length: number;
        draw: () => void;
        pause: false | number;
        offset: number;
        isSetup: boolean;
        setup?: () => void;
    }[];
    params: InputSchema["params"];
    progress: {
        point: number;
        time: number;
        curve: number;
        seed: number;
        indexes: number[];
        countNums: number[];
        accums: number[];
        accumIndex: number;
        letter: number;
        scrub: number;
        scrubTime: number;
        progress: number;
        regexCache: Record<string, string[]>;
    };
    live: {
        keys: string[];
    };
    pointConstants: Record<string, (...args: string[]) => BasicPt>;
    constants: Record<string, ((...args: string[]) => number) | (() => number)>;
    reservedConstants: string[];
    fonts: Record<string, AsemicFont>;
    currentFont: string;
    lastPoint: AsemicPt;
    noiseTable: ((x: number) => number)[];
    noiseValues: number[];
    noiseIndex: number;
    images: Record<string, ImageData[]>;
    output: {
        osc: {
            path: string;
            args: (string | number | [number, number])[];
        }[];
        sc: {
            path: string;
            value: number | number[];
        }[];
        scSynthDefs: Record<string, string>;
        curves: any[];
        errors: string[];
        pauseAt: string | false;
        eval: string[];
        params: InputSchema | undefined;
        presets: InputSchema | undefined;
        resetParams: boolean;
        resetPresets: boolean;
        files: string[];
    };
    preProcessing: {
        replacements: Record<string, string>;
        width: number;
        height: number;
        directory: string;
    };
    private expressions;
    private drawing;
    private transformMethods;
    private textMethods;
    private utilities;
    private scenes;
    private oscMethods;
    private parsing;
    private data;
    constructor(additionalConstants?: Parser['constants']);
    private mixinMethods;
    expr: ExpressionMethods['expr'];
    choose: ExpressionMethods['choose'];
    def: ExpressionMethods['def'];
    defStatic: ExpressionMethods['defStatic'];
    tri: DrawingMethods['tri'];
    squ: DrawingMethods['squ'];
    pen: DrawingMethods['pen'];
    hex: DrawingMethods['hex'];
    circle: DrawingMethods['circle'];
    seq: DrawingMethods['seq'];
    line: DrawingMethods['line'];
    to: TransformMethods['to'];
    parseTransform: TransformMethods['parseTransform'];
    applyTransform: TransformMethods['applyTransform'];
    reverseTransform: TransformMethods['reverseTransform'];
    textMethod: TextMethods['text'];
    font: TextMethods['font'];
    resetFont: TextMethods['resetFont'];
    keys: TextMethods['keys'];
    regex: TextMethods['regex'];
    repeat: UtilityMethods['repeat'];
    within: UtilityMethods['within'];
    center: UtilityMethods['center'];
    each: UtilityMethods['each'];
    test: UtilityMethods['test'];
    or: UtilityMethods['or'];
    noise: UtilityMethods['noise'];
    getBounds: UtilityMethods['getBounds'];
    scene: SceneMethods['scene'];
    play: SceneMethods['play'];
    param: SceneMethods['param'];
    preset: SceneMethods['preset'];
    toPreset: SceneMethods['toPreset'];
    scrub: SceneMethods['scrub'];
    oscMethod: OSCMethods['osc'];
    sc: OSCMethods['sc'];
    synth: OSCMethods['synth'];
    file: OSCMethods['file'];
    tokenize: ParsingMethods['tokenize'];
    parsePoint: ParsingMethods['parsePoint'];
    parseArgs: ParsingMethods['parseArgs'];
    evalPoint: ParsingMethods['evalPoint'];
    group: ParsingMethods['group'];
    end: ParsingMethods['end'];
    points: ParsingMethods['points'];
    loadFiles: DataMethods['loadFiles'];
    table: DataMethods['table'];
    processMouse: DataMethods['processMouse'];
    resolveName: DataMethods['resolveName'];
    osc(args: string): any;
    getDynamicValue(value: number | (() => number)): number;
    error(text: string): void;
    reset({ newFrame }?: {
        newFrame?: boolean;
    }): void;
    draw(): void;
    debug(slice?: number): string;
    set(settings: Partial<this['settings']>): this;
    setup(source: string): void;
    hash: (n: number) => number;
    cloneTransform: typeof cloneTransform;
    get duration(): number;
}
