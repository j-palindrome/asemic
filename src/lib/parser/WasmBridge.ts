/**
 * TypeScript Bridge for WASM Parser
 *
 * Provides TypeScript-friendly interface to AssemblyScript WASM module
 */

import { AsemicPt } from '../blocks/AsemicPt'
import { AsemicGroup } from './core/AsemicGroup'
import type { Transform } from '../types'

/** WASM module exports (generated by AssemblyScript) */
interface WasmExports {
  // Initialization
  init(width: number, height: number): void
  reset(): void

  // Progress
  setProgress(
    time: number,
    scrub: number,
    scrubTime: number,
    progress: number,
    seed: number
  ): void
  setIndexes(
    i0: number,
    i1: number,
    i2: number,
    n0: number,
    n1: number,
    n2: number
  ): void

  // Transform
  setTransform(
    tx: number,
    ty: number,
    sx: number,
    sy: number,
    rotation: number,
    cx: number,
    cy: number
  ): void
  resetTransform(): void

  // Expression evaluation
  expr(input: number): number // Note: string passed as pointer
  hash(n: number): number
  lerp(a: number, b: number, t: number): number

  // Drawing
  tri(x: number, y: number, w: number, h: number): void
  squ(x: number, y: number, w: number, h: number): void
  pen(sides: number, x: number, y: number, w: number, h: number): void
  hex(x: number, y: number, w: number, h: number): void
  circle(x: number, y: number, w: number, h: number, segments: number): void
  seq(count: number, x: number, y: number, xStep: number, yStep: number): void
  line(x1: number, y1: number, x2: number, y2: number, segments: number): void

  // Curves
  getCurveCount(): number
  getCurvePointCount(curveIndex: number): number
  getCurvePoint(
    curveIndex: number,
    pointIndex: number
  ): { x: number; y: number }
  exportCurves(): Float64Array
  clearCurves(): void
  interpolate(curveIndex: number, targetCount: number): void
  getTangent(curveIndex: number, progress: number): number

  // Memory
  memory: WebAssembly.Memory
  __newString(str: string): number
  __getString(ptr: number): string
  __pin(ptr: number): number
  __unpin(ptr: number): void
}

/**
 * WASM-accelerated drawing methods
 *
 * Use this class when you need maximum performance for curve generation.
 * Falls back to TypeScript implementation if WASM is not available.
 */
export class WasmDrawingMethods {
  private wasm: WasmExports | null = null
  private ready: boolean = false
  private parser: any // Reference to Parser instance

  constructor(parser: any) {
    this.parser = parser
  }

  /** Initialize WASM module */
  async init(wasmPath: string = '/assembly/index.wasm'): Promise<boolean> {
    try {
      const { instance } = await WebAssembly.instantiateStreaming(
        fetch(wasmPath),
        {
          env: {
            abort: () => console.error('WASM aborted')
          }
        }
      )

      this.wasm = instance.exports as unknown as WasmExports
      this.wasm.init(
        this.parser.preProcessing.width,
        this.parser.preProcessing.height
      )
      this.ready = true
      return true
    } catch (error) {
      console.warn(
        'Failed to load WASM module, using TypeScript fallback:',
        error
      )
      return false
    }
  }

  /** Check if WASM is ready */
  isReady(): boolean {
    return this.ready && this.wasm !== null
  }

  /** Sync state from Parser to WASM */
  private syncState(): void {
    if (!this.wasm) return

    const p = this.parser.progress
    this.wasm.setProgress(p.time, p.scrub, p.scrubTime, p.progress, p.seed)

    this.wasm.setIndexes(
      p.indexes[0] ?? 0,
      p.indexes[1] ?? 0,
      p.indexes[2] ?? 0,
      p.countNums[0] ?? 0,
      p.countNums[1] ?? 0,
      p.countNums[2] ?? 0
    )

    // Sync transform
    const t = this.parser.currentTransform
    this.wasm.setTransform(
      t.translate?.[0] ?? 0,
      t.translate?.[1] ?? 0,
      t.scale?.[0] ?? 1,
      t.scale?.[1] ?? 1,
      t.rotate ?? 0,
      t.center?.[0] ?? 0,
      t.center?.[1] ?? 0
    )
  }

  /** Get curves from WASM and convert to AsemicPt format */
  private exportCurves(): AsemicGroup[] {
    if (!this.wasm) return []

    const flatData = this.wasm.exportCurves()
    const groups: AsemicGroup[] = []
    let offset = 0

    const curveCount = flatData[offset++]

    for (let i = 0; i < curveCount; i++) {
      const pointCount = flatData[offset++]
      const curve: AsemicPt[] = []

      for (let j = 0; j < pointCount; j++) {
        const x = flatData[offset++]
        const y = flatData[offset++]
        curve.push(new AsemicPt(this.parser, x, y))
      }

      // Each curve becomes its own group
      const group = new AsemicGroup(
        this.parser.settings,
        this.parser.preProcessing
      )
      group.push(curve)
      groups.push(group)
    }

    this.wasm.clearCurves()
    return groups
  }

  // ============================================================================
  // Drawing Methods (WASM-accelerated)
  // ============================================================================

  /** Triangle */
  tri(...args: string[]): void {
    if (!this.isReady()) {
      this.parser.drawing.tri(...args)
      return
    }

    this.syncState()
    const [x, y, w, h] = args.map(a => this.parser.expr(a))
    this.wasm!.tri(x, y, w, h ?? w)

    // Export and add to parser
    const groups = this.exportCurves()
    this.parser.groups.push(...groups)
  }

  /** Square */
  squ(...args: string[]): void {
    if (!this.isReady()) {
      this.parser.drawing.squ(...args)
      return
    }

    this.syncState()
    const [x, y, w, h] = args.map(a => this.parser.expr(a))
    this.wasm!.squ(x, y, w, h ?? w)

    const groups = this.exportCurves()
    this.parser.groups.push(...groups)
  }

  /** Pentagon */
  pen(...args: string[]): void {
    if (!this.isReady()) {
      this.parser.drawing.pen(...args)
      return
    }

    this.syncState()
    const [sides, x, y, w, h] = args.map(a => this.parser.expr(a))
    this.wasm!.pen(sides, x, y, w, h ?? w)

    const groups = this.exportCurves()
    this.parser.groups.push(...groups)
  }

  /** Hexagon */
  hex(...args: string[]): void {
    if (!this.isReady()) {
      this.parser.drawing.hex(...args)
      return
    }

    this.syncState()
    const [x, y, w, h] = args.map(a => this.parser.expr(a))
    this.wasm!.hex(x, y, w, h ?? w)

    const groups = this.exportCurves()
    this.parser.groups.push(...groups)
  }

  /** Circle */
  circle(...args: string[]): void {
    if (!this.isReady()) {
      this.parser.drawing.circle(...args)
      return
    }

    this.syncState()
    const [x, y, w, h, segments] = args.map(a => this.parser.expr(a))
    this.wasm!.circle(x, y, w, h ?? w, segments ?? 8)

    const groups = this.exportCurves()
    this.parser.groups.push(...groups)
  }

  /** Sequence */
  seq(...args: string[]): void {
    if (!this.isReady()) {
      this.parser.drawing.seq(...args)
      return
    }

    this.syncState()
    const [count, x, y, xStep, yStep] = args.map(a => this.parser.expr(a))
    this.wasm!.seq(count, x, y, xStep, yStep)

    const groups = this.exportCurves()
    this.parser.groups.push(...groups)
  }

  /** Line */
  line(...args: string[]): void {
    if (!this.isReady()) {
      this.parser.drawing.line(...args)
      return
    }

    this.syncState()
    const [x1, y1, x2, y2, segments] = args.map(a => this.parser.expr(a))
    this.wasm!.line(x1, y1, x2, y2, segments ?? 2)

    const groups = this.exportCurves()
    this.parser.groups.push(...groups)
  }

  // ============================================================================
  // Expression Evaluation (WASM-accelerated)
  // ============================================================================

  /** Evaluate expression */
  expr(expression: string): number {
    if (!this.isReady()) {
      return this.parser.expressions.expr(expression)
    }

    this.syncState()

    // For simple numbers, parse directly
    const num = parseFloat(expression)
    if (!isNaN(num)) {
      return num
    }

    // Pass to WASM
    const strPtr = this.wasm!.__newString(expression)
    const result = this.wasm!.expr(strPtr)
    this.wasm!.__unpin(strPtr)

    return result
  }

  /** Hash function */
  hash(n: number): number {
    if (!this.isReady()) {
      return this.parser.hash(n)
    }
    return this.wasm!.hash(n)
  }

  /** Lerp function */
  lerp(a: number, b: number, t: number): number {
    if (!this.isReady()) {
      return a + (b - a) * t
    }
    return this.wasm!.lerp(a, b, t)
  }
}

/**
 * Helper to enable WASM acceleration in existing Parser
 */
export async function enableWasm(
  parser: any,
  wasmPath?: string
): Promise<boolean> {
  const wasmMethods = new WasmDrawingMethods(parser)
  const success = await wasmMethods.init(wasmPath)

  if (success) {
    // Replace drawing methods with WASM versions
    parser._wasmMethods = wasmMethods

    // Monkey-patch drawing methods to use WASM
    const methodNames = ['tri', 'squ', 'pen', 'hex', 'circle', 'seq', 'line']
    methodNames.forEach(name => {
      parser[name] = (...args: any[]) => wasmMethods[name](...args)
    })

    console.log('âœ“ WASM acceleration enabled')
  }

  return success
}
